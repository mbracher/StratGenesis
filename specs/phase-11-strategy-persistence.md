# Phase 11: Strategy Persistence

## Objective

Add functionality to persist evolved strategies to disk, enabling reuse, analysis, and deployment of successful strategies discovered during evolution.

From the design considerations:

> Evolved strategies exist only in memory during execution. When the program exits, all dynamically generated strategy classes are lost. This phase adds persistence to save strategies as importable Python modules with associated metadata.

---

## Requirements

### What to Persist

1. **Strategy Source Code** - The complete Python class definition
2. **Metadata** - Performance metrics, lineage, timestamps, and context
3. **Run Summary** - Aggregated results across all folds

### When to Persist

- After each strategy is accepted into the population (meets MAS threshold)
- At the end of walk-forward optimization (summary file)

### Output Organization

```
output_dir/
├── run_20250114_153042/           # Timestamped run directory
│   ├── run_summary.json           # Overall run metadata and results
│   ├── fold_1/
│   │   ├── EMACrossover_Gen3.py   # Strategy source code
│   │   ├── EMACrossover_Gen3.json # Strategy metadata
│   │   ├── EMACrossover_Gen7.py
│   │   ├── EMACrossover_Gen7.json
│   │   └── best_strategy.py       # Symlink or copy of best for this fold
│   ├── fold_2/
│   │   └── ...
│   └── best_overall.py            # Best strategy across all folds
```

---

## StrategyPersister Class

### Location

Add to `src/profit/evolver.py` (or create new `src/profit/persistence.py`)

### Constructor

```python
class StrategyPersister:
    """Handles saving evolved strategies to disk."""

    def __init__(self, output_dir: str = "evolved_strategies"):
        """Initialize the persister.

        Args:
            output_dir: Base directory for saving strategies (default: evolved_strategies/).
        """
        self.output_dir = Path(output_dir)
        self.run_dir = None  # Set when run starts
        self.run_id = None
```

### Method: start_run()

```python
def start_run(self, seed_strategy_name: str, provider: str, model: str) -> Path:
    """Initialize a new run directory.

    Args:
        seed_strategy_name: Name of the seed strategy being evolved.
        provider: LLM provider (openai/anthropic).
        model: LLM model name.

    Returns:
        Path to the run directory.
    """
    self.run_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    self.run_dir = self.output_dir / f"run_{self.run_id}"
    self.run_dir.mkdir(parents=True, exist_ok=True)

    # Save initial run info
    run_info = {
        "run_id": self.run_id,
        "started_at": datetime.now().isoformat(),
        "seed_strategy": seed_strategy_name,
        "llm_provider": provider,
        "llm_model": model,
        "folds": [],
    }
    self._write_json(self.run_dir / "run_summary.json", run_info)

    return self.run_dir
```

---

### Method: save_strategy()

```python
def save_strategy(
    self,
    strategy_class,
    source_code: str,
    fold: int,
    generation: int,
    metrics: dict,
    parent_name: str,
    improvement_proposal: str,
) -> Path:
    """Save an evolved strategy to disk.

    Args:
        strategy_class: The strategy class object.
        source_code: Complete Python source code of the strategy.
        fold: Walk-forward fold number (1-indexed).
        generation: Evolution generation number.
        metrics: Performance metrics dict (AnnReturn%, Sharpe, etc.).
        parent_name: Name of the parent strategy this was derived from.
        improvement_proposal: The LLM's improvement proposal text.

    Returns:
        Path to the saved strategy file.
    """
    fold_dir = self.run_dir / f"fold_{fold}"
    fold_dir.mkdir(exist_ok=True)

    class_name = strategy_class.__name__

    # Save source code as .py file
    strategy_path = fold_dir / f"{class_name}.py"
    header = self._generate_header(class_name, fold, generation, metrics)
    self._write_file(strategy_path, header + source_code)

    # Save metadata as .json file
    metadata = {
        "class_name": class_name,
        "fold": fold,
        "generation": generation,
        "parent_strategy": parent_name,
        "improvement_proposal": improvement_proposal,
        "metrics": metrics,
        "saved_at": datetime.now().isoformat(),
    }
    self._write_json(fold_dir / f"{class_name}.json", metadata)

    return strategy_path
```

### Method: _generate_header()

```python
def _generate_header(
    self, class_name: str, fold: int, generation: int, metrics: dict
) -> str:
    """Generate a header comment for the strategy file.

    Returns:
        String with imports and docstring header.
    """
    return f'''"""Evolved Strategy: {class_name}

Generated by ProFiT evolutionary optimization.
Fold: {fold} | Generation: {generation}
Annualized Return: {metrics.get("AnnReturn%", "N/A"):.2f}%
Sharpe Ratio: {metrics.get("Sharpe", "N/A"):.2f}

Auto-generated - do not edit manually.
"""

import numpy as np
import pandas as pd
from backtesting import Strategy


'''
```

---

### Method: save_fold_best()

```python
def save_fold_best(
    self, fold: int, strategy_class, source_code: str, metrics: dict
) -> Path:
    """Save the best strategy for a fold.

    Creates a copy named 'best_strategy.py' in the fold directory.

    Args:
        fold: Fold number.
        strategy_class: Best strategy class for this fold.
        source_code: Source code of the strategy.
        metrics: Performance metrics.

    Returns:
        Path to the best strategy file.
    """
    fold_dir = self.run_dir / f"fold_{fold}"
    best_path = fold_dir / "best_strategy.py"

    header = f'''"""Best Strategy for Fold {fold}

Original class: {strategy_class.__name__}
Annualized Return: {metrics.get("AnnReturn%", "N/A"):.2f}%
Sharpe Ratio: {metrics.get("Sharpe", "N/A"):.2f}
"""

import numpy as np
import pandas as pd
from backtesting import Strategy


'''
    self._write_file(best_path, header + source_code)
    return best_path
```

---

### Method: finalize_run()

```python
def finalize_run(self, results: list[dict]) -> Path:
    """Finalize the run and save summary.

    Args:
        results: List of per-fold result dictionaries from walk_forward_optimize.

    Returns:
        Path to the run summary file.
    """
    summary_path = self.run_dir / "run_summary.json"
    summary = self._read_json(summary_path)

    # Add fold results
    for res in results:
        fold_info = {
            "fold": res["fold"],
            "best_strategy": res["strategy"].__name__,
            "ann_return": res["ann_return"],
            "sharpe": res["sharpe"],
            "expectancy": res["expectancy"],
            "vs_random": res["ann_return"] - res["random_return"],
            "vs_buy_hold": res["ann_return"] - res["buy_hold_return"],
        }
        summary["folds"].append(fold_info)

    # Add aggregate stats
    summary["completed_at"] = datetime.now().isoformat()
    summary["avg_ann_return"] = np.mean([r["ann_return"] for r in results])
    summary["avg_sharpe"] = np.mean([r["sharpe"] for r in results])
    summary["best_fold"] = max(results, key=lambda r: r["ann_return"])["fold"]

    self._write_json(summary_path, summary)

    # Copy best overall strategy
    best_result = max(results, key=lambda r: r["ann_return"])
    best_fold_dir = self.run_dir / f"fold_{best_result['fold']}"
    best_src = best_fold_dir / "best_strategy.py"
    if best_src.exists():
        shutil.copy(best_src, self.run_dir / "best_overall.py")

    return summary_path
```

---

### Helper Methods

```python
def _write_file(self, path: Path, content: str) -> None:
    """Write string content to file."""
    path.write_text(content)

def _write_json(self, path: Path, data: dict) -> None:
    """Write dict as JSON to file."""
    path.write_text(json.dumps(data, indent=2))

def _read_json(self, path: Path) -> dict:
    """Read JSON file as dict."""
    return json.loads(path.read_text())
```

---

## Integration with ProfitEvolver

### Modified Constructor

```python
def __init__(
    self,
    llm_client: LLMClient,
    initial_capital: float = 10000,
    commission: float = 0.002,
    exclusive_orders: bool = True,
    output_dir: str | None = "evolved_strategies",  # NEW
):
    self.llm = llm_client
    self.initial_capital = initial_capital
    self.commission = commission
    self.exclusive_orders = exclusive_orders

    # Initialize persister if output_dir provided
    self.persister = StrategyPersister(output_dir) if output_dir else None
```

### Modified evolve_strategy()

Add `fold` parameter and save accepted strategies:

```python
def evolve_strategy(
    self,
    strategy_class,
    train_data: pd.DataFrame,
    val_data: pd.DataFrame,
    max_iters: int = 15,
    fold: int = 1,  # NEW: fold number for persistence
):
    # ... existing code ...

    # After accepting a new strategy (line ~273):
    if P_new is not None and P_new >= MAS:
        population.append((NewStrategyClass, P_new))

        # NEW: Persist the accepted strategy
        if self.persister:
            self.persister.save_strategy(
                strategy_class=NewStrategyClass,
                source_code=new_code,
                fold=fold,
                generation=gen,
                metrics={"AnnReturn%": P_new, "Sharpe": res.get("Sharpe Ratio")},
                parent_name=parent_class.__name__,
                improvement_proposal=improvement,
            )

    # ... rest of existing code ...
```

### Modified walk_forward_optimize()

```python
def walk_forward_optimize(
    self, full_data: pd.DataFrame, strategy_class, n_folds: int = 5
) -> list[dict]:
    # NEW: Start persistence run
    if self.persister:
        self.persister.start_run(
            seed_strategy_name=strategy_class.__name__,
            provider=self.llm.provider,
            model=self.llm.model,
        )

    folds = self.prepare_folds(full_data, n_folds=n_folds)
    results = []

    for i, (train, val, test) in enumerate(folds, start=1):
        # ... existing code ...

        # Pass fold number to evolve_strategy
        best_strat, _ = self.evolve_strategy(
            strategy_class, train, val, fold=i  # NEW
        )

        # ... existing backtest code ...

        # NEW: Save best strategy for this fold
        if self.persister:
            self.persister.save_fold_best(
                fold=i,
                strategy_class=best_strat,
                source_code=inspect.getsource(best_strat),
                metrics=metrics,
            )

        results.append({...})

    # NEW: Finalize run with summary
    if self.persister:
        self.persister.finalize_run(results)

    return results
```

---

## CLI Updates (main.py)

### New Argument

```python
parser.add_argument(
    "--output-dir",
    default="evolved_strategies",
    help="Directory to save evolved strategies (use 'none' to disable)",
)
```

### Updated Evolver Initialization

```python
output_dir = None if args.output_dir.lower() == "none" else args.output_dir

evolver = ProfitEvolver(
    llm_client,
    initial_capital=args.capital,
    commission=args.commission,
    output_dir=output_dir,  # NEW
)
```

---

## Loading Saved Strategies

### Utility Function

```python
def load_strategy(strategy_path: str):
    """Load a saved strategy from a .py file.

    Args:
        strategy_path: Path to the saved strategy Python file.

    Returns:
        The strategy class ready for backtesting.

    Example:
        >>> strat = load_strategy("evolved_strategies/run_20250114/fold_1/best_strategy.py")
        >>> bt = Backtest(data, strat, cash=10000)
        >>> bt.run()
    """
    from pathlib import Path
    import importlib.util

    path = Path(strategy_path)
    spec = importlib.util.spec_from_file_location(path.stem, path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    # Find the Strategy subclass in the module
    for name, obj in vars(module).items():
        if isinstance(obj, type) and issubclass(obj, Strategy) and obj is not Strategy:
            return obj

    raise ValueError(f"No Strategy subclass found in {strategy_path}")
```

---

## Example Output

### Strategy File (EMACrossover_Gen5.py)

```python
"""Evolved Strategy: EMACrossover_Gen5

Generated by ProFiT evolutionary optimization.
Fold: 1 | Generation: 5
Annualized Return: 18.42%
Sharpe Ratio: 1.23

Auto-generated - do not edit manually.
"""

import numpy as np
import pandas as pd
from backtesting import Strategy


class EMACrossover_Gen5(Strategy):
    fast_period = 8
    slow_period = 21
    atr_period = 14

    def init(self):
        close = self.data.Close
        self.fast_ema = self.I(lambda: pd.Series(close).ewm(span=self.fast_period).mean())
        self.slow_ema = self.I(lambda: pd.Series(close).ewm(span=self.slow_period).mean())
        # ... rest of strategy code
```

### Metadata File (EMACrossover_Gen5.json)

```json
{
  "class_name": "EMACrossover_Gen5",
  "fold": 1,
  "generation": 5,
  "parent_strategy": "EMACrossover_Gen3",
  "improvement_proposal": "Add ATR-based position sizing to reduce drawdown during volatile periods",
  "metrics": {
    "AnnReturn%": 18.42,
    "Sharpe": 1.23,
    "Expectancy%": 2.15,
    "Trades": 127
  },
  "saved_at": "2025-01-14T15:35:22.456789"
}
```

### Run Summary (run_summary.json)

```json
{
  "run_id": "20250114_153042",
  "started_at": "2025-01-14T15:30:42.123456",
  "completed_at": "2025-01-14T16:45:18.789012",
  "seed_strategy": "EMACrossover",
  "llm_provider": "openai",
  "llm_model": "gpt-4",
  "folds": [
    {
      "fold": 1,
      "best_strategy": "EMACrossover_Gen5",
      "ann_return": 18.42,
      "sharpe": 1.23,
      "expectancy": 2.15,
      "vs_random": 15.67,
      "vs_buy_hold": 8.21
    }
  ],
  "avg_ann_return": 15.83,
  "avg_sharpe": 1.15,
  "best_fold": 1
}
```

---

## Deliverables

- [x] `StrategyPersister` class with all methods
- [x] Integration into `ProfitEvolver.__init__()` with `output_dir` parameter
- [x] Modified `evolve_strategy()` to save accepted strategies
- [x] Modified `walk_forward_optimize()` to manage run lifecycle
- [x] `load_strategy()` utility function
- [x] CLI `--output-dir` argument
- [x] Unit tests for persistence functionality
